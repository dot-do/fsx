/**
 * SQLiteMetadata - SQLite-backed metadata store for fsx
 *
 * Stores filesystem metadata in SQLite (via Durable Objects or D1).
 * Uses INTEGER PRIMARY KEY for efficient rowid-based lookups.
 */

import type { FileEntry, FileType, BlobRef } from '../core/types.js'

/**
 * Internal file row structure matching the SQLite schema.
 * Uses integer rowid for efficient storage and lookups.
 */
interface FileRow {
  id: number
  path: string
  name: string
  parent_id: number | null
  type: string
  mode: number
  uid: number
  gid: number
  size: number
  blob_id: string | null
  link_target: string | null
  tier: string
  atime: number
  mtime: number
  ctime: number
  birthtime: number
  nlink: number
}

/**
 * SQLiteMetadata - Filesystem metadata backed by SQLite
 */
export class SQLiteMetadata {
  private sql: SqlStorage

  constructor(sql: SqlStorage) {
    this.sql = sql
  }

  /**
   * Initialize the database schema.
   * Uses INTEGER PRIMARY KEY AUTOINCREMENT for efficient rowid-based storage.
   */
  async init(): Promise<void> {
    await this.sql.exec(`
      CREATE TABLE IF NOT EXISTS files (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        path TEXT UNIQUE NOT NULL,
        name TEXT NOT NULL,
        parent_id INTEGER,
        type TEXT NOT NULL CHECK(type IN ('file', 'directory', 'symlink')),
        mode INTEGER NOT NULL DEFAULT 420,
        uid INTEGER NOT NULL DEFAULT 0,
        gid INTEGER NOT NULL DEFAULT 0,
        size INTEGER NOT NULL DEFAULT 0,
        blob_id TEXT,
        link_target TEXT,
        tier TEXT NOT NULL DEFAULT 'hot' CHECK(tier IN ('hot', 'warm', 'cold')),
        atime INTEGER NOT NULL,
        mtime INTEGER NOT NULL,
        ctime INTEGER NOT NULL,
        birthtime INTEGER NOT NULL,
        nlink INTEGER NOT NULL DEFAULT 1,
        FOREIGN KEY (parent_id) REFERENCES files(id) ON DELETE CASCADE
      );

      CREATE INDEX IF NOT EXISTS idx_files_path ON files(path);
      CREATE INDEX IF NOT EXISTS idx_files_parent ON files(parent_id);
      CREATE INDEX IF NOT EXISTS idx_files_tier ON files(tier);

      CREATE TABLE IF NOT EXISTS blobs (
        id TEXT PRIMARY KEY,
        tier TEXT NOT NULL DEFAULT 'hot' CHECK(tier IN ('hot', 'warm', 'cold')),
        size INTEGER NOT NULL,
        checksum TEXT,
        created_at INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_blobs_tier ON blobs(tier);
    `)

    // Create root if not exists
    const root = await this.getByPath('/')
    if (!root) {
      const now = Date.now()
      await this.sql.exec(
        `INSERT INTO files (path, name, parent_id, type, mode, uid, gid, size, tier, atime, mtime, ctime, birthtime, nlink)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        '/',
        '',
        null,
        'directory',
        0o755,
        0,
        0,
        0,
        'hot',
        now,
        now,
        now,
        now,
        2
      )
    }
  }

  /**
   * Convert a FileRow to a FileEntry
   */
  private rowToEntry(row: FileRow): FileEntry {
    return {
      id: String(row.id),
      path: row.path,
      name: row.name,
      parentId: row.parent_id !== null ? String(row.parent_id) : null,
      type: row.type as FileType,
      mode: row.mode,
      uid: row.uid,
      gid: row.gid,
      size: row.size,
      blobId: row.blob_id,
      linkTarget: row.link_target,
      atime: row.atime,
      mtime: row.mtime,
      ctime: row.ctime,
      birthtime: row.birthtime,
      nlink: row.nlink,
    }
  }

  /**
   * Get entry by path
   */
  async getByPath(path: string): Promise<FileEntry | null> {
    const result = await this.sql.exec<FileRow>('SELECT * FROM files WHERE path = ?', path).one()
    return result ? this.rowToEntry(result) : null
  }

  /**
   * Get entry by ID
   */
  async getById(id: string): Promise<FileEntry | null> {
    const numericId = parseInt(id, 10)
    if (isNaN(numericId)) return null
    const result = await this.sql.exec<FileRow>('SELECT * FROM files WHERE id = ?', numericId).one()
    return result ? this.rowToEntry(result) : null
  }

  /**
   * Get children of a directory
   */
  async getChildren(parentId: string): Promise<FileEntry[]> {
    const numericId = parseInt(parentId, 10)
    if (isNaN(numericId)) return []
    const rows = this.sql.exec<FileRow>('SELECT * FROM files WHERE parent_id = ?', numericId).toArray()
    return rows.map((row) => this.rowToEntry(row))
  }

  /**
   * Create a new entry.
   * Note: id is auto-generated by SQLite, so it's not included in the insert.
   */
  async createEntry(entry: {
    path: string
    name: string
    parentId: string | null
    type: FileType
    mode: number
    uid: number
    gid: number
    size: number
    blobId: string | null
    linkTarget: string | null
    nlink: number
    tier?: 'hot' | 'warm' | 'cold'
  }): Promise<number> {
    const now = Date.now()
    const parentIdNum = entry.parentId !== null ? parseInt(entry.parentId, 10) : null
    await this.sql.exec(
      `INSERT INTO files (path, name, parent_id, type, mode, uid, gid, size, blob_id, link_target, tier, atime, mtime, ctime, birthtime, nlink)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      entry.path,
      entry.name,
      parentIdNum,
      entry.type,
      entry.mode,
      entry.uid,
      entry.gid,
      entry.size,
      entry.blobId,
      entry.linkTarget,
      entry.tier ?? 'hot',
      now,
      now,
      now,
      now,
      entry.nlink
    )
    // Return the last inserted rowid
    const result = await this.sql.exec<{ id: number }>('SELECT last_insert_rowid() as id').one()
    return result?.id ?? 0
  }

  /**
   * Update an entry
   */
  async updateEntry(
    id: string,
    updates: Partial<{
      path: string
      name: string
      parentId: string | null
      mode: number
      uid: number
      gid: number
      size: number
      blobId: string | null
      tier: 'hot' | 'warm' | 'cold'
      atime: number
      mtime: number
    }>
  ): Promise<void> {
    const numericId = parseInt(id, 10)
    if (isNaN(numericId)) return

    const sets: string[] = []
    const values: unknown[] = []

    if (updates.path !== undefined) {
      sets.push('path = ?')
      values.push(updates.path)
    }
    if (updates.name !== undefined) {
      sets.push('name = ?')
      values.push(updates.name)
    }
    if (updates.parentId !== undefined) {
      sets.push('parent_id = ?')
      const parentIdNum = updates.parentId !== null ? parseInt(updates.parentId, 10) : null
      values.push(parentIdNum)
    }
    if (updates.mode !== undefined) {
      sets.push('mode = ?')
      values.push(updates.mode)
    }
    if (updates.uid !== undefined) {
      sets.push('uid = ?')
      values.push(updates.uid)
    }
    if (updates.gid !== undefined) {
      sets.push('gid = ?')
      values.push(updates.gid)
    }
    if (updates.size !== undefined) {
      sets.push('size = ?')
      values.push(updates.size)
    }
    if (updates.blobId !== undefined) {
      sets.push('blob_id = ?')
      values.push(updates.blobId)
    }
    if (updates.tier !== undefined) {
      sets.push('tier = ?')
      values.push(updates.tier)
    }
    if (updates.atime !== undefined) {
      sets.push('atime = ?')
      values.push(updates.atime)
    }
    if (updates.mtime !== undefined) {
      sets.push('mtime = ?')
      values.push(updates.mtime)
    }

    // Always update ctime
    sets.push('ctime = ?')
    values.push(Date.now())

    values.push(numericId)

    await this.sql.exec(`UPDATE files SET ${sets.join(', ')} WHERE id = ?`, ...values)
  }

  /**
   * Delete an entry
   */
  async deleteEntry(id: string): Promise<void> {
    const numericId = parseInt(id, 10)
    if (isNaN(numericId)) return
    await this.sql.exec('DELETE FROM files WHERE id = ?', numericId)
  }

  /**
   * Register a blob
   */
  async registerBlob(blob: { id: string; tier: 'hot' | 'warm' | 'cold'; size: number; checksum?: string }): Promise<void> {
    await this.sql.exec('INSERT INTO blobs (id, tier, size, checksum, created_at) VALUES (?, ?, ?, ?, ?)', blob.id, blob.tier, blob.size, blob.checksum || null, Date.now())
  }

  /**
   * Get blob info
   */
  async getBlob(id: string): Promise<BlobRef | null> {
    const result = await this.sql.exec<BlobRef>('SELECT * FROM blobs WHERE id = ?', id).one()
    return result || null
  }

  /**
   * Update blob tier
   */
  async updateBlobTier(id: string, tier: 'hot' | 'warm' | 'cold'): Promise<void> {
    await this.sql.exec('UPDATE blobs SET tier = ? WHERE id = ?', tier, id)
  }

  /**
   * Delete a blob reference
   */
  async deleteBlob(id: string): Promise<void> {
    await this.sql.exec('DELETE FROM blobs WHERE id = ?', id)
  }

  /**
   * Find entries by pattern (glob-like)
   */
  async findByPattern(pattern: string, parentPath?: string): Promise<FileEntry[]> {
    // Convert glob to SQL LIKE pattern
    const sqlPattern = pattern.replace(/\*/g, '%').replace(/\?/g, '_')

    let rows: FileRow[]
    if (parentPath) {
      rows = this.sql.exec<FileRow>('SELECT * FROM files WHERE path LIKE ? AND path LIKE ?', parentPath + '%', sqlPattern).toArray()
    } else {
      rows = this.sql.exec<FileRow>('SELECT * FROM files WHERE path LIKE ?', sqlPattern).toArray()
    }

    return rows.map((row) => this.rowToEntry(row))
  }

  /**
   * Get storage statistics
   */
  async getStats(): Promise<{
    totalFiles: number
    totalDirectories: number
    totalSize: number
    blobsByTier: Record<string, { count: number; size: number }>
  }> {
    const files = await this.sql.exec<{ count: number }>(`SELECT COUNT(*) as count FROM files WHERE type = 'file'`).one()
    const dirs = await this.sql.exec<{ count: number }>(`SELECT COUNT(*) as count FROM files WHERE type = 'directory'`).one()
    const size = await this.sql.exec<{ total: number }>('SELECT SUM(size) as total FROM files').one()

    const tierStats = await this.sql.exec<{ tier: string; count: number; size: number }>('SELECT tier, COUNT(*) as count, SUM(size) as size FROM blobs GROUP BY tier').toArray()

    const blobsByTier: Record<string, { count: number; size: number }> = {}
    for (const stat of tierStats) {
      blobsByTier[stat.tier] = { count: stat.count, size: stat.size }
    }

    return {
      totalFiles: files?.count || 0,
      totalDirectories: dirs?.count || 0,
      totalSize: size?.total || 0,
      blobsByTier,
    }
  }
}
